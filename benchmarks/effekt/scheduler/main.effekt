
import exndequeue
import args
import bench

interface Tick {
  def tick(): Unit
}

interface Process {
  def yield(): Unit
  def exit(): Nothing
  def fork (p: () => Unit / Process at {}): Unit
}

def scheduler { prog: => Unit / Process }: Unit / Tick = region this {
  try {
    val queue: Queue[() => Unit at {this, prog, e, global}] at {this, e, global} = box newQueue{this}{e};

    def driver(): Unit = {
      (queue.dequeue)();
      driver()
    }

    def spawn(prog1: () => Unit / Process at {this, prog, e, global} ): Unit = {
      try { prog1() } with Process {
        def yield() = {
          queue.enqueue(box { resume(()) })
        }
        def fork( p: () => Unit / Process at {} ) = {
          queue.enqueue(box { resume(()) })
          // here we first run it in its original place and then also handle Process
          spawn(p)
        }
        def exit() = ()
      }
    }

    spawn(prog)
    driver()
    
  } with e: Exception {()}
}

def job(): Unit / Process = {
  do yield ()
}

def jobs(i: Int): Unit / {Process, Tick} = {
  if (i == 0) 
    ()
  else {
    do fork (job)
    do tick()
    jobs(i - 1)
  }
}

def run(n: Int, init: Int) = {
  var c = init
  try {
    scheduler { jobs(n) }
  } with Tick {
    def tick() = {
      c = c + 1
      resume(())
    }
  }
  c
}

def step(i: Int, acc: Int, n: Int): Int = {
  if (i == 0) {
    acc
  } else {
    step(i - 1, run(n, acc), n)
  }
}

def main() = ignore[WrongFormat] {commandLineArgs() match {
  case Nil() => println("Expects one argument")
  case Cons(x, Cons(y, Nil())) =>
    println("Measuring internal running time")
    val i = x.toInt; var r = 0; val t = timed{ r = step(1000, 0, i); };
    println("Nanosecond used: " ++ show(t))
    println(r)
  case Cons(x, Nil()) =>
    val i = x.toInt; val r = step(1000, 0, i);
    println(r)
  case other => println("Expects one argument, not '" ++ show(size(other)) ++ "'")
}
}