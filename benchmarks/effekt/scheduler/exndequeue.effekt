module exndequeue

import ref

effect Exception: Nothing

type QueueCell[R] {
  QueueNil();
  QueueCons(cell: Ref[(R, QueueCell[R])])
}

interface Queue[R] {
  def clear(): Unit
  def enqueue(x: R): Unit
  def dequeue(): R / Exception
  def peek(): R / Exception
  def isEmpty(): Bool
}

def newQueue[R]{r: Region}{e: Exception}: Queue[R] at {r, global, e} = {
  var first in r = QueueNil()
  var last in r = QueueNil()
  var size in r = 0
  new Queue[R] {

    def clear() = {
      first = QueueNil()
      last = QueueNil()
      size = 0
    }

    def enqueue(x: R) = {
      val newCell = allocate()
      newCell.set((x, QueueNil()))
      val newCons = QueueCons(newCell)
      last match {
        case QueueNil() => {
          first = newCons;
          last = newCons;
          size = 1
        }
        case QueueCons(lastCell) => {
          size = size + 1;
          lastCell.set((lastCell.get().first, newCons))
          last = newCons
        }
      }
    }

    def dequeue() = {
      first match {
        case QueueNil() => e.Exception()
        case QueueCons(firstCell) => {
          val next = firstCell.get().second
          next match {
            case QueueNil() => {
              first = QueueNil()
              last = QueueNil()
              size = 0
              firstCell.get().first
            }
            case QueueCons(nextCell) => {
              first = next;
              size = size - 1;
              firstCell.get().first
            }
          }
        }
      }
    }

    def peek() = {
      first match {
        case QueueNil() => e.Exception()
        case QueueCons(cell) => cell.get().first
      }
    }

    def isEmpty() = size == 0

  }
}